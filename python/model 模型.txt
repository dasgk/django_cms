1. setting.py  数据库配置
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'xzbwg',
        'USER': 'root',
        'PASSWORD': 'hdwnmp',
        'HOST': '127.0.0.1',
        'PORT': '3306',
    }
}

2. 模型类的路径定义
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'mysite.models',  #这里是自己定义的模型类的路径
]

3.model 模型类 类似定义
from django.db import models

class Exhibit(models.Model):
    exhibit_id = models.IntegerField(primary_key=True)
    content = models.TextField()
    video_path = models.CharField(max_length=255)
    created_at = models.DateTimeField()
    updated_at = models.DateTimeField()

    class Meta:
        db_table = "hd_exhibit"

		
4. 模型查找，返回一条数据
exhibit_obj = Exhibit.objects.filter(exhibit_id=1).first()   这样，找到数据返回的是 Exhibit对象，未找到数据 返回的是None

//返回多条数据

exhibit_list = Exhibit.objects.filter(exhibit_id=1).all()
for i in exhibit_list:
    print(i.content)
	
	
正序排列
exhibit_list = Exhibit.objects.filter(exhibit_id=1).order_by('exhibit_id').all()
倒序排列
exhibit_list = Exhibit.objects.filter(exhibit_id=1).order_by('-exhibit_id').all()
//多个字段排序
Articlelist = Article.objects.order_by('-nid','ctime')


// 返回特定列， 并且返回的是多个列
exhibit_list = Exhibit.objects.filter(exhibit_id=1).order_by('exhibit_id').values('content','exhibit_id').all()
print(exhibit_list)

//返回一个字典
exhibit_list = Exhibit.objects.filter(exhibit_id=1).order_by('exhibit_id').values('content','exhibit_id').first()
if exhibit_list != None:
	print(exhibit_list.content)

// 返回数量 
 Book.objects.filter(publisher__name='BaloneyPress').count()
//返回最大值
Book.objects.all().aggregate(Max('price'))
  
//返回平均值
Book.objects.all().aggregate(Avg('price'))
//返回综合
 Student.objects.aggregate(Sum('age'))
  
get 返回一个对象，

新建一个对象，或者多个对象
方式1 ：  Exhibit.objects.create(content="这是新建内容",video_path="去百度看吧",created_at="2018-11-14 00:00:00",updated_at="2018-11-14 09:00:00")
方式2：
test = Exhibit(content="这是新建内容",video_path="去百度看吧",created_at="2018-11-14 00:00:00",updated_at="2018-11-14 09:00:00")
test.content = '这是最新的内容'
test.save()

方式3 
Exhibit.objects.get_or_create(content="WZT", created_at="2018-11-14 03:33:02", updated_at="2018-11-14 03:33:02")

product_list_to_insert = list()
for x in range(10):
    product_list_to_insert.append(Product(name='product name ' + str(x), price=x))
Product.objects.bulk_create(product_list_to_insert)



修改的方式自然也就这样了，现在看下批量修改


批量更新数据
批量更新数据时，先进行数据过滤，然后再调用update方法进行一次性地更新。下面的语句将生成类似update...where...的SQL语句。
Exhibit.objects.filter(video_path__contains='哈').update(video_path="这是新内容",updated_at="2019-11-10 00:00:00")
自然删除也是这么删除了
Exhibit.objects.filter(content__contains='WZT').delete()



where条件查询
Person.objects.filter(name="abc")  # 等于Person.objects.filter(name__exact="abc") 名称严格等于 "abc" 的人

Person.objects.filter(name__iexact="abc")  # 名称为 abc 但是不区分大小写，可以找到 ABC, Abc, aBC，这些都符合条件

Person.objects.filter(name__contains="abc")  # 名称中包含 "abc"的人

Person.objects.filter(name__icontains="abc")  #名称中包含 "abc"，且abc不区分大小写



Person.objects.filter(name__regex="^abc")  # 正则表达式查询

Person.objects.filter(name__iregex="^abc")  # 正则表达式不区分大小写

Person.objects.filter(name__contains="abc").exclude(age=23)  # 找出名称含有abc, 但是排除年龄是23岁的